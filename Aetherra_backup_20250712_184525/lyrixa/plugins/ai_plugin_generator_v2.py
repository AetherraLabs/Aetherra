"""
AI-Driven Plugin Generator v2
=============================

Advanced AI-powered system for generating intelligent, contextual plugins
based on user requirements, patterns, and best practices.
"""

import ast
import json
import os
from datetime import datetime
from typing import Dict, List


class PluginTemplate:
    """Plugin template definition."""
    # Required plugin metadata
    name = "ai_plugin_generator_v2"
    description = "PluginTemplate - Auto-generated description"
    input_schema = {
        "type": "object",
        "properties": {
            "input": {"type": "string", "description": "Input data"}
        },
        "required": ["input"]
    }
    output_schema = {
        "type": "object",
        "properties": {
            "result": {"type": "string", "description": "Processing result"},
            "status": {"type": "string", "description": "Operation status"}
        }
    }
    created_by = "Plugin System Auto-Fixer"


    def __init__(
        self, name: str, category: str, template: str, metadata: Dict | None = None
    ):
        self.name = name
        self.category = category
        self.template = template
        self.metadata = metadata or {}
        self.usage_count = 0
        self.success_rate = 0.0


class AIPluginGenerator:
    """AI-driven plugin generation system."""

    def __init__(self):
        self.templates = {}
        self.generation_history = []
        self.learning_data = {}
        self.patterns = {}
        self._initialize_templates()
        self._load_learning_data()

    def _initialize_templates(self):
        """Initialize default plugin templates."""

        # Basic plugin template
        basic_template = '''"""
{description}

Generated by Lyrixa AI Plugin Generator
Author: {author}
Category: {category}
"""

import json
from typing import Dict, List, Any

__version__ = "{version}"
__author__ = "{author}"
__category__ = "{category}"
__description__ = "{description}"

class {class_name}:
    """
    {description}
    """

    def __init__(self):
        self.name = "{plugin_name}"
        self.version = "{version}"
        self.initialized = True
        {init_code}

    def execute(self, *args, **kwargs) -> Any:
        """
        Main execution method for the plugin.

        Args:
            *args: Variable arguments
            **kwargs: Keyword arguments

        Returns:
            Plugin execution result
        """
        try:
            {execution_code}
            return self._process_result(result)
        except Exception as e:
            return {{"error": str(e), "success": False}}

    def _process_result(self, result: Any) -> Dict:
        """Process and format the result."""
        return {{
            "success": True,
            "result": result,
            "plugin": self.name,
            "timestamp": datetime.now().isoformat()
        }}

    def get_info(self) -> Dict:
        """Get plugin information."""
        return {{
            "name": self.name,
            "version": self.version,
            "category": "{category}",
            "description": "{description}",
            "author": "{author}",
            "capabilities": {capabilities}
        }}

    def cleanup(self):
        """Cleanup method called when plugin is unloaded."""
        pass

{additional_methods}

# Plugin instance
plugin_instance = {class_name}()

def main(*args, **kwargs):
    """Main function for direct plugin execution."""
    return plugin_instance.execute(*args, **kwargs)
'''

        self.templates["basic"] = PluginTemplate(
            "basic",
            "general",
            basic_template,
            {"complexity": "low", "features": ["execute", "get_info"]},
        )

        # Data processing template
        data_template = '''"""
{description}

Advanced data processing plugin with filtering, transformation, and analysis capabilities.
"""

import json
import time
from typing import Dict, List, Any, Union
from datetime import datetime

__version__ = "{version}"
__author__ = "{author}"
__category__ = "data"
__description__ = "{description}"

class {class_name}:
    """
    Advanced data processing plugin.
    """

    def __init__(self):
        self.name = "{plugin_name}"
        self.version = "{version}"
        self.processors = {{}}
        self.filters = {{}}
        self.cache = {{}}

    def execute(self, data: Any, operation: str = "process", **kwargs) -> Dict:
        """
        Process data with specified operation.

        Args:
            data: Input data to process
            operation: Processing operation ('process', 'filter', 'transform', 'analyze')
            **kwargs: Additional parameters

        Returns:
            Processing result
        """
        try:
            if operation == "process":
                result = self._process_data(data, **kwargs)
            elif operation == "filter":
                result = self._filter_data(data, **kwargs)
            elif operation == "transform":
                result = self._transform_data(data, **kwargs)
            elif operation == "analyze":
                result = self._analyze_data(data, **kwargs)
            else:
                raise ValueError(f"Unknown operation: {{operation}}")

            return {{
                "success": True,
                "result": result,
                "operation": operation,
                "processed_items": len(data) if isinstance(data, (list, dict)) else 1,
                "timestamp": datetime.now().isoformat()
            }}

        except Exception as e:
            return {{
                "success": False,
                "error": str(e),
                "operation": operation
            }}

    def _process_data(self, data: Any, **kwargs) -> Any:
        """Process data with custom logic."""
        {processing_code}
        return processed_data

    def _filter_data(self, data: Any, criteria: Dict = None, **kwargs) -> Any:
        """Filter data based on criteria."""
        if not criteria:
            return data

        if isinstance(data, list):
            return [item for item in data if self._meets_criteria(item, criteria)]
        elif isinstance(data, dict):
            return {{k: v for k, v in data.items() if self._meets_criteria(v, criteria)}}
        else:
            return data if self._meets_criteria(data, criteria) else None

    def _transform_data(self, data: Any, transformations: List = None, **kwargs) -> Any:
        """Transform data using specified transformations."""
        if not transformations:
            return data

        result = data
        for transform in transformations:
            result = self._apply_transformation(result, transform)
        return result

    def _analyze_data(self, data: Any, **kwargs) -> Dict:
        """Analyze data and return insights."""
        analysis = {{
            "type": type(data).__name__,
            "size": len(data) if hasattr(data, '__len__') else 1,
            "timestamp": datetime.now().isoformat()
        }}

        if isinstance(data, (list, tuple)):
            analysis.update({{
                "item_types": list(set(type(item).__name__ for item in data)),
                "empty_items": sum(1 for item in data if not item)
            }})
        elif isinstance(data, dict):
            analysis.update({{
                "keys": list(data.keys()),
                "value_types": list(set(type(v).__name__ for v in data.values()))
            }})

        return analysis

    def _meets_criteria(self, item: Any, criteria: Dict) -> bool:
        """Check if item meets filtering criteria."""
        for key, value in criteria.items():
            if hasattr(item, key):
                if getattr(item, key) != value:
                    return False
            elif isinstance(item, dict) and key in item:
                if item[key] != value:
                    return False
        return True

    def _apply_transformation(self, data: Any, transform: Dict) -> Any:
        """Apply a single transformation to data."""
        transform_type = transform.get('type', 'identity')

        if transform_type == 'map':
            func = transform.get('function')
            if func and isinstance(data, list):
                return [func(item) for item in data]
        elif transform_type == 'reduce':
            # Simple reduction implementation
            if isinstance(data, list) and data:
                return sum(data) if all(isinstance(x, (int, float)) for x in data) else data[0]

        return data

    def get_info(self) -> Dict:
        """Get plugin information."""
        return {{
            "name": self.name,
            "version": self.version,
            "category": "data",
            "description": "{description}",
            "capabilities": ["process", "filter", "transform", "analyze"],
            "supported_operations": ["process", "filter", "transform", "analyze"]
        }}

# Plugin instance
plugin_instance = {class_name}()

def main(*args, **kwargs):
    """Main function for direct plugin execution."""
    return plugin_instance.execute(*args, **kwargs)
'''

        self.templates["data"] = PluginTemplate(
            "data",
            "data",
            data_template,
            {
                "complexity": "medium",
                "features": ["data_processing", "filtering", "analysis"],
            },
        )

        # API interaction template
        api_template = '''"""
{description}

API interaction plugin with request handling, response processing, and error management.
"""

import json
import time
from typing import Dict, List, Any, Optional
from datetime import datetime

__version__ = "{version}"
__author__ = "{author}"
__category__ = "api"
__description__ = "{description}"

class {class_name}:
    """
    API interaction plugin with comprehensive request handling.
    """

    def __init__(self):
        self.name = "{plugin_name}"
        self.version = "{version}"
        self.base_url = ""
        self.headers = {{"Content-Type": "application/json"}}
        self.timeout = 30
        self.retry_count = 3

    def execute(self, method: str = "GET", url: str = "", data: Any = None, **kwargs) -> Dict:
        """
        Execute API request.

        Args:
            method: HTTP method (GET, POST, PUT, DELETE)
            url: API endpoint URL
            data: Request data/payload
            **kwargs: Additional parameters

        Returns:
            API response result
        """
        try:
            # Simulate API request (replace with actual implementation)
            response = self._make_request(method, url, data, **kwargs)

            return {{
                "success": True,
                "response": response,
                "status_code": 200,
                "method": method,
                "url": url,
                "timestamp": datetime.now().isoformat()
            }}

        except Exception as e:
            return {{
                "success": False,
                "error": str(e),
                "method": method,
                "url": url
            }}

    def _make_request(self, method: str, url: str, data: Any = None, **kwargs) -> Dict:
        """Make HTTP request (mock implementation)."""
        # This is a mock implementation - replace with actual HTTP library
        time.sleep(0.1)  # Simulate network delay

        return {{
            "message": f"Mock {{method}} request to {{url}}",
            "data": data,
            "timestamp": datetime.now().isoformat()
        }}

    def _handle_response(self, response: Any) -> Dict:
        """Handle and process API response."""
        # Process response based on content type and status
        return {{"processed": True, "data": response}}

    def _retry_request(self, method: str, url: str, data: Any = None, retries: int = 3) -> Any:
        """Retry failed requests with exponential backoff."""
        for attempt in range(retries):
            try:
                return self._make_request(method, url, data)
            except Exception as e:
                if attempt == retries - 1:
                    raise e
                time.sleep(2 ** attempt)  # Exponential backoff

    def get_info(self) -> Dict:
        """Get plugin information."""
        return {{
            "name": self.name,
            "version": self.version,
            "category": "api",
            "description": "{description}",
            "capabilities": ["GET", "POST", "PUT", "DELETE"],
            "features": ["retry", "timeout", "error_handling"]
        }}

# Plugin instance
plugin_instance = {class_name}()

def main(*args, **kwargs):
    """Main function for direct plugin execution."""
    return plugin_instance.execute(*args, **kwargs)
'''

        self.templates["api"] = PluginTemplate(
            "api",
            "integration",
            api_template,
            {
                "complexity": "medium",
                "features": ["http_requests", "error_handling", "retry_logic"],
            },
        )

    def _load_learning_data(self):
        """Load learning data from previous generations."""
        try:
            data_file = os.path.join(
                os.path.dirname(__file__), "generator_learning_data.json"
            )
            if os.path.exists(data_file):
                with open(data_file, "r") as f:
                    self.learning_data = json.load(f)
        except Exception as e:
            print(f"Could not load learning data: {e}")
            self.learning_data = {}

    def _save_learning_data(self):
        """Save learning data for future improvements."""
        try:
            data_file = os.path.join(
                os.path.dirname(__file__), "generator_learning_data.json"
            )
            with open(data_file, "w") as f:
                json.dump(self.learning_data, f, indent=2)
        except Exception as e:
            print(f"Could not save learning data: {e}")

    def generate_plugin(self, requirements: Dict) -> Dict:
        """
        Generate a plugin based on requirements.

        Args:
            requirements: Dictionary containing plugin requirements
                - name: Plugin name
                - description: Plugin description
                - category: Plugin category
                - functionality: List of required functions
                - complexity: Desired complexity level
                - template: Preferred template (optional)

        Returns:
            Generated plugin information and code
        """
        try:
            # Extract requirements
            plugin_name = requirements.get("name", "generated_plugin")
            category = requirements.get("category", "general")
            functionality = requirements.get("functionality", [])
            complexity = requirements.get("complexity", "medium")
            preferred_template = requirements.get("template")

            # Select appropriate template
            template = self._select_template(
                category, functionality, complexity, preferred_template
            )

            # Generate plugin parameters
            params = self._generate_plugin_parameters(requirements, template)

            # Generate code
            plugin_code = self._generate_code(template, params)

            # Validate generated code
            validation_result = self._validate_generated_code(plugin_code)

            # Record generation
            generation_record = {
                "timestamp": datetime.now().isoformat(),
                "requirements": requirements,
                "template_used": template.name,
                "validation_passed": validation_result["valid"],
                "plugin_name": plugin_name,
            }
            self.generation_history.append(generation_record)

            # Update learning data
            self._update_learning_data(generation_record, validation_result)

            return {
                "success": True,
                "plugin_name": plugin_name,
                "plugin_code": plugin_code,
                "validation": validation_result,
                "template_used": template.name,
                "generation_id": len(self.generation_history) - 1,
            }

        except Exception as e:
            return {"success": False, "error": str(e)}

    def _select_template(
        self,
        category: str,
        functionality: List,
        complexity: str,
        preferred: str | None = None,
    ) -> PluginTemplate:
        """Select the most appropriate template."""
        if preferred and preferred in self.templates:
            return self.templates[preferred]

        # Score templates based on requirements
        template_scores = {}

        for name, template in self.templates.items():
            score = 0

            # Category match
            if template.category == category:
                score += 10

            # Complexity match
            template_complexity = template.metadata.get("complexity", "medium")
            if template_complexity == complexity:
                score += 5

            # Functionality match
            template_features = template.metadata.get("features", [])
            matching_features = set(functionality) & set(template_features)
            score += len(matching_features) * 3

            # Usage history bias
            if name in self.learning_data:
                success_rate = self.learning_data[name].get("success_rate", 0.5)
                score += success_rate * 5

            template_scores[name] = score

        # Select highest scoring template
        best_template = max(template_scores.items(), key=lambda x: x[1])[0]
        return self.templates[best_template]

    def _generate_plugin_parameters(
        self, requirements: Dict, template: PluginTemplate
    ) -> Dict:
        """Generate parameters for plugin code generation."""
        plugin_name = requirements.get("name", "generated_plugin")

        # Generate class name
        class_name = "".join(word.capitalize() for word in plugin_name.split("_"))
        if not class_name.endswith("Plugin"):
            class_name += "Plugin"

        # Generate basic parameters
        params = {
            "plugin_name": plugin_name,
            "class_name": class_name,
            "description": requirements.get("description", "Auto-generated plugin"),
            "author": requirements.get("author", "Lyrixa AI Generator"),
            "version": requirements.get("version", "1.0.0"),
            "category": requirements.get("category", "general"),
            "capabilities": requirements.get("functionality", []),
            "init_code": "",
            "execution_code": "",
            "additional_methods": "",
            "processing_code": "",
        }

        # Generate template-specific code
        if template.name == "data":
            params["processing_code"] = self._generate_data_processing_code(
                requirements
            )
        elif template.name == "api":
            params["init_code"] = 'self.base_url = kwargs.get("base_url", "")'

        # Generate execution code based on functionality
        execution_lines = []
        for func in requirements.get("functionality", []):
            if func == "text_processing":
                execution_lines.append(
                    'result = self._process_text(args[0] if args else "")'
                )
            elif func == "data_analysis":
                execution_lines.append(
                    "result = self._analyze_data(args[0] if args else [])"
                )
            elif func == "file_processing":
                execution_lines.append(
                    'result = self._process_file(args[0] if args else "")'
                )
            else:
                execution_lines.append(f"result = self._handle_{func}(*args, **kwargs)")

        if not execution_lines:
            execution_lines.append(
                'result = {"message": "Plugin executed successfully", "args": args, "kwargs": kwargs}'
            )

        params["execution_code"] = "\\n            ".join(execution_lines)

        # Generate additional methods
        additional_methods = []
        for func in requirements.get("functionality", []):
            method_code = self._generate_method_code(func)
            if method_code:
                additional_methods.append(method_code)

        params["additional_methods"] = "\\n\\n".join(additional_methods)

        return params

    def _generate_data_processing_code(self, requirements: Dict) -> str:
        """Generate data processing specific code."""
        return """
        processed_data = data
        if isinstance(data, str):
            processed_data = data.strip().lower()
        elif isinstance(data, list):
            processed_data = [str(item).strip() for item in data]
        elif isinstance(data, dict):
            processed_data = {k: str(v).strip() for k, v in data.items()}
        """

    def _generate_method_code(self, functionality: str) -> str:
        """Generate code for specific functionality methods."""
        method_templates = {
            "text_processing": '''    def _process_text(self, text: str) -> str:
        """Process input text."""
        return text.strip().lower().replace(' ', '_')''',
            "data_analysis": '''    def _analyze_data(self, data: List) -> Dict:
        """Analyze input data."""
        return {
            "count": len(data),
            "types": list(set(type(item).__name__ for item in data)),
            "sample": data[:5] if data else []
        }''',
            "file_processing": '''    def _process_file(self, filepath: str) -> Dict:
        """Process file."""
        return {
            "filepath": filepath,
            "processed": True,
            "message": f"File {filepath} processed successfully"
        }''',
        }

        return method_templates.get(functionality, "")

    def _generate_code(self, template: PluginTemplate, params: Dict) -> str:
        """Generate the final plugin code."""
        try:
            return template.template.format(**params)
        except KeyError as e:
            # Handle missing parameters
            missing_param = str(e).strip("'")
            params[missing_param] = f"TODO: Define {missing_param}"
            return template.template.format(**params)

    def _validate_generated_code(self, code: str) -> Dict:
        """Validate generated plugin code."""
        validation_result = {
            "valid": False,
            "errors": [],
            "warnings": [],
            "suggestions": [],
        }

        try:
            # Parse AST to check syntax
            tree = ast.parse(code)
            validation_result["valid"] = True

            # Check for required components
            classes = [
                node for node in ast.walk(tree) if isinstance(node, ast.ClassDef)
            ]
            if not classes:
                validation_result["warnings"].append(
                    "No classes found in generated code"
                )

            functions = [
                node for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)
            ]
            if not functions:
                validation_result["warnings"].append(
                    "No functions found in generated code"
                )

            # Check for execute method
            execute_methods = [
                node
                for node in ast.walk(tree)
                if isinstance(node, ast.FunctionDef) and node.name == "execute"
            ]
            if not execute_methods:
                validation_result["warnings"].append("No execute method found")

        except SyntaxError as e:
            validation_result["errors"].append(f"Syntax error: {e}")
        except Exception as e:
            validation_result["errors"].append(f"Validation error: {e}")

        return validation_result

    def _update_learning_data(self, generation_record: Dict, validation_result: Dict):
        """Update learning data based on generation results."""
        template_name = generation_record["template_used"]

        if template_name not in self.learning_data:
            self.learning_data[template_name] = {
                "usage_count": 0,
                "success_count": 0,
                "success_rate": 0.0,
                "common_errors": [],
                "improvement_suggestions": [],
            }

        # Update usage statistics
        self.learning_data[template_name]["usage_count"] += 1

        if validation_result["valid"]:
            self.learning_data[template_name]["success_count"] += 1

        # Update success rate
        usage = self.learning_data[template_name]["usage_count"]
        success = self.learning_data[template_name]["success_count"]
        self.learning_data[template_name]["success_rate"] = (
            success / usage if usage > 0 else 0
        )

        # Track errors
        for error in validation_result.get("errors", []):
            if error not in self.learning_data[template_name]["common_errors"]:
                self.learning_data[template_name]["common_errors"].append(error)

        # Save updated learning data
        self._save_learning_data()

    def get_generation_history(self) -> List[Dict]:
        """Get plugin generation history."""
        return self.generation_history.copy()

    def get_template_stats(self) -> Dict:
        """Get template usage statistics."""
        stats = {}
        for name, template in self.templates.items():
            learning_data = self.learning_data.get(name, {})
            stats[name] = {
                "category": template.category,
                "complexity": template.metadata.get("complexity", "unknown"),
                "features": template.metadata.get("features", []),
                "usage_count": learning_data.get("usage_count", 0),
                "success_rate": learning_data.get("success_rate", 0.0),
            }
        return stats

    def suggest_improvements(self, plugin_code: str) -> List[str]:
        """Suggest improvements for existing plugin code."""
        suggestions = []

        try:
            tree = ast.parse(plugin_code)

            # Check for docstrings
            classes = [
                node for node in ast.walk(tree) if isinstance(node, ast.ClassDef)
            ]
            for cls in classes:
                if not (
                    cls.body
                    and isinstance(cls.body[0], ast.Expr)
                    and isinstance(cls.body[0].value, ast.Constant)
                ):
                    suggestions.append(f"Add docstring to class {cls.name}")

            # Check for error handling
            try_blocks = [node for node in ast.walk(tree) if isinstance(node, ast.Try)]
            functions = [
                node for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)
            ]

            if len(try_blocks) < len(functions) * 0.5:
                suggestions.append(
                    "Consider adding more error handling with try-except blocks"
                )

            # Check for type hints
            type_hinted_functions = 0
            for func in functions:
                if func.returns or any(arg.annotation for arg in func.args.args):
                    type_hinted_functions += 1

            if type_hinted_functions < len(functions) * 0.7:
                suggestions.append("Consider adding type hints to improve code clarity")

        except Exception as e:
            suggestions.append(f"Could not analyze code: {e}")

        return suggestions


# Global generator instance
ai_generator = AIPluginGenerator()


def generate_plugin(requirements: Dict) -> Dict:
    """Convenience function for plugin generation."""
    return ai_generator.generate_plugin(requirements)


def get_available_templates() -> List[str]:
    """Get list of available templates."""
    return list(ai_generator.templates.keys())
